#!/usr/bin/env python
#
# Input:   <s, c, 1>
#             s = number of sides to the shape
#             c = color (0 = black, 1 = red, 2 = blue, 4 = green)
# 
# Hidden Layer
# Activation: <s - 3 - c, s - 3 + c>
#                 [ 1  1]
#     <s, c, 1> . [-1  1]  =  <a, b>
#                 [-3 -3]
#
# 
# Output Layer
# Activation: <3a + 5b>
#                  [ 3]
#      <a, b, 1> . [ 5] = <3a + 5b>
#                  [ 0]
#
def f(s, c):
    a = s - 3 - c
    b = s - 3 + c
    return [a, b]
def g(a, b, w1, w2):
    return w1 * a + w2 * b

import sys

# Map of number of polygon sides to a name -- 0, 1, and 2 are
# not valid side counts so leave them as non-valued:
shapes = [None, None, None, 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon' ]

# Map of color value to a name, where 0=black, 1=red, etc.
# and additive colors (red + blue = purple) are the sum of
# the base color values; since red=1 and blue=2, purple=3:
colors = ['black', 'red', 'blue', 'purple', 'green', 'yellow', 'cyan', 'white']

# Initial values for neural net parameters:
s = None
c = None
w1 = 3
w2 = 5

# Display help if requested:
if '-h' in sys.argv or '--help' in sys.argv:
    print("""usage:

    {:s} | <s> <c> {{{{<w1>}} <w2>}} | <w2>
    
    <s>  : number of polygon sides
    <c>  : color value, [0...7]
    <w1> : weight of output from hidden layer neuron 1 (default: {:d})
    <w2> : weight of output from hidden layer neuron 2 (default: {:d})
    
    With no arguments the full range of <s> and <c> are enumerated.

""".format(sys.argv[0], w1, w2))
    exit(0)

# Check for command line arguments, altering the neural net
# parameters as necessary:
if len(sys.argv) == 2:
    w2 = int(sys.argv[1])
elif len(sys.argv) >= 3:
    s = int(sys.argv[1])
    c = int(sys.argv[2])
    if len(sys.argv) == 4:
        w2 = int(sys.argv[3])
    elif len(sys.argv) == 5:
        w1 = int(sys.argv[3])
        w2 = int(sys.argv[4])
# Validate any parameter changes:
if s is not None and (s < 3 or s > 8):
    print('ERROR:  Polygon side count invalid: {:d}'.format(s))
    exit(1)
if c is not None and (c < 0 or c > 7):
    print('ERROR:  Color value invalid: {:d}'.format(c))
    exit(1)
# Generate the range of <s> and <c> values that will be enumerated:
s_range = range(3, 9) if s is None else range(s, s+1)
c_range = range(0, 8) if c is None else range(c, c+1)

# Initialize the output, singular output-to-parameter mapping, and
# the multi-valued mapping (repeats):
O = []
O_map = {}
O_repeats = {}

# Explore all combinations of <s> and <c>:
for s in s_range:
    for c in c_range:
        # Get hidden layer outputs based on <s> and <c>:
        o1 = f(s, c)
        # Compute output layer based on hidden layer outputs and
        # weights:
        o2 = g(*o1, w1=w1, w2=w2)
        # Add the output to the list of all outputs w/ repetitions:
        O.append(o2)
        # Add the singular mapping:
        O_map[o2] = (s, c, '{:s} {:s}'.format(colors[c], shapes[s]))
        # Add the multi-valued mapping:
        if o2 in O_repeats:
            O_repeats[o2].append(O_map[o2])
        else:
            O_repeats[o2] = [O_map[o2]]
        # Print the information associated with this combination of
        # <s> and <c>:
        print('({:2d},{:2d}) = <{:d},{:d}>.{:<12s} = {:4d}'.format(s, c, w1, w2, str(o1), o2))

# All done; display the singular mappings by increasing neural net
# output value (the keys):
for k in sorted(O_map.keys()):
    print('{:4d} => {:s} @ ({:d},{:d})'.format(k, O_map[k][2], O_map[k][0], O_map[k][1]))

# Also show the multi-valued mapping so we can see which inputs yielded
# overlapping outputs:
print('Repeats:')
for k in sorted(O_repeats.keys()):
    print('{:4d} => {:s}'.format(k, str(O_repeats[k])))

# Finally, summarize the total number of combinations of <s> and <c>
# versus the number of unique outputs generated by the neural net; if
# the two numbers are the same, then all inputs have a unique output!
print('Number of pairs is {:d} vs. unique pairs {:d}'.format(len(O), len(set(O))))
